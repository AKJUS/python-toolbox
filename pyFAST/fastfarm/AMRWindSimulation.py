import numpy as np
from pathlib import Path

class AMRWindSimulation:
    '''
    This class is used to help prepare sampling planes for an AMR-Wind
      simulation. The sampling planes will be used to generate inflow
      data for FAST.Farm simulations.
    Specifically, this class contains info from the AMR-Wind input file,
      and it carries out simple calculations about the AMR-Wind
      simulation
    '''

    def __init__(self, dt: float, prob_lo: tuple, prob_hi: tuple, 
                    n_cell: tuple, max_level: int, 
                    incflo_velocity_hh: tuple, 
                    postproc_name='sampling'):
        '''
        Values from the AMR-Wind input file
        Inputs:
          * dt: this should be a fixed dt value
          * incflo_velocity_hh: velocity vector, specifically at hub height
        '''
        # Process inputs
        self.dt = dt
        self.prob_lo = prob_lo
        self.prob_hi = prob_hi
        self.n_cell = n_cell
        self.max_level = max_level
        self.incflo_velocity_hh = incflo_velocity_hh
        self.postproc_name = postproc_name

        # Placeholder variables, to be calculated by FFCaseCreation
        self.output_frequency = None
        self.sampling_labels = None
        self.ds_lr = None
        self.ds_hr = None
        self.nx_lr = None
        self.ny_lr = None
        self.nz_lr = None
        self.xlow_lr = None
        self.xhigh_lr = None
        self.ylow_lr = None
        self.yhigh_lr = None
        self.zlow_lr = None
        self.zhigh_lr = None
        self.zoffsets_lr = None
        self.hr_domains = None

        # Run extra functions
        self._checkInputs()
        self._calc_amr_params()

    def _checkInputs(self):
        '''
        Check that the AMR-Wind inputs make sense
        '''
        if len(self.prob_lo) != 3:
            raise ValueError(f"prob_lo must contain 3 elements, but it has {len(self.prob_lo)}")
        if len(self.prob_hi) != 3:
            raise ValueError(f"prob_hi must contain 3 elements, but it has {len(self.prob_hi)}")
        if len(self.incflo_velocity_hh) != 3:
            raise ValueError(f"incflo_velocity_hh must contain 3 elements, but it has {len(self.incflo_velocity_hh)}")
        if (self.prob_lo[0] >= self.prob_hi[0]):
            raise ValueError("x-component of prob_lo larger than x-component of prob_hi")
        if (self.prob_lo[1] >= self.prob_hi[1]):
            raise ValueError("y-component of prob_lo larger than y-component of prob_hi")
        if (self.prob_lo[2] >= self.prob_hi[2]):
            raise ValueError("z-component of prob_lo larger than z-component of prob_hi")

    def _calc_amr_params(self):
        '''
        Calculate simulation parameters, given only AMR-Wind inputs
        '''
        # Grid resolution at Level 0
        self.dx0 = (self.prob_hi[0] - self.prob_lo[0]) / self.n_cell[0]
        self.dy0 = (self.prob_hi[1] - self.prob_lo[1]) / self.n_cell[1]
        self.dz0 = (self.prob_hi[2] - self.prob_lo[2]) / self.n_cell[2]
        self.ds0_max = max(self.dx0, self.dy0, self.dz0)

        # Grid resolution at finest refinement level
        self.dx_refine = self.dx0/(2**self.max_level)
        self.dy_refine = self.dy0/(2**self.max_level)
        self.dz_refine = self.dz0/(2**self.max_level)
        self.refine_max = max(self.dx_refine, self.dy_refine, self.dz_refine)

        # Hub height wind speed
        self.vhub = np.sqrt(self.incflo_velocity_hh[0]**2 + self.incflo_velocity_hh[1]**2)

    def write_sampling_params(self, outdir):
        '''
        Write out text that can be used for the sampling planes in an 
          AMR-Wind input file
        '''
        outfile = Path(outdir, 'sampling_config.i')
        if outfile.is_file():
            raise FileExistsError(f"{str(outfile)} already exists! Aborting...")

        with outfile.open("w") as out:
            # Write high-level info for sampling
            out.write(f"# Sampling info generated by AMRWindSamplingCreation.py\n")
            out.write(f"incflo.post_processing = {self.postproc_name} # averaging\n")
            out.write(f"{self.postproc_name}.output_frequency = {self.output_frequency}\n")
            out.write(f"{self.postproc_name}.fields = velocity # temperature tke\n")
            out.write(f"{self.postproc_name}.labels = {self.sampling_labels}\n")

            # Write out low resolution sampling plane info
            zoffsets_lr_str = " ".join(str(int(item)) for item in self.zoffsets_lr)

            out.write(f"\n# Low sampling grid spacing: {self.ds_lr} m\n")
            out.write(f"{self.postproc_name}.Low.type         = PlaneSampler\n")
            out.write(f"{self.postproc_name}.Low.num_points   = {self.nx_lr} {self.ny_lr}\n")
            out.write(f"{self.postproc_name}.Low.origin       = {self.xlow_lr:.1f} {self.ylow_lr:.1f}\n")  # Round the float output
            out.write(f"{self.postproc_name}.Low.axis1        = {self.xdist_lr:.1f} 0.0 0.0\n")  # Assume: axis1 oriented parallel to AMR-Wind x-axis
            out.write(f"{self.postproc_name}.Low.axis2        = 0.0 {self.ydist_lr:.1f} 0.0\n")  # Assume: axis2 oriented parallel to AMR-Wind y-axis
            out.write(f"{self.postproc_name}.Low.normal       = 0.0 0.0 1.0\n")
            out.write(f"{self.postproc_name}.Low.offsets      = {zoffsets_lr_str}\n")

            # Write out high resolution sampling plane info
            for turbkey in self.hr_domains:
                wt_name = f'T{turbkey}'
                nx_hr = self.hr_domains[turbkey]['nx_hr']
                ny_hr = self.hr_domains[turbkey]['ny_hr']
                xlow_hr = self.hr_domains[turbkey]['xlow_hr']
                ylow_hr = self.hr_domains[turbkey]['ylow_hr']
                xdist_hr = self.hr_domains[turbkey]['xdist_hr']
                ydist_hr = self.hr_domains[turbkey]['ydist_hr']
                zoffsets_hr = self.hr_domains[turbkey]['zoffsets_hr']
                zoffsets_hr_str = " ".join(str(int(item)) for item in zoffsets_hr)

                out.write(f"\n# Turbine {wt_name}\n")
                out.write(f"{self.postproc_name}.{wt_name}.type         = PlaneSampler\n")
                out.write(f"{self.postproc_name}.{wt_name}.num_points   = {nx_hr} {ny_hr}\n")
                out.write(f"{self.postproc_name}.{wt_name}.origin       = {xlow_hr:.1f} {ylow_hr:.1f}\n")  # Round the float output
                out.write(f"{self.postproc_name}.{wt_name}.axis1        = {xdist_hr:.1f} 0.0 0.0\n")  # Assume: axis1 oriented parallel to AMR-Wind x-axis
                out.write(f"{self.postproc_name}.{wt_name}.axis2        = 0.0 {ydist_hr:.1f} 0.0\n")  # Assume: axis2 oriented parallel to AMR-Wind y-axis
                out.write(f"{self.postproc_name}.{wt_name}.normal       = 0.0 0.0 1.0\n")
                out.write(f"{self.postproc_name}.{wt_name}.offsets      = {zoffsets_hr_str}\n")